[{"id":0,"href":"/algodoc/docs/leetcode/hard/1235/","title":"1235. Maximum Profit in Job Scheduling","section":"Hard","content":" 466. Arithmetic Slices II - Subsequence # 1235. Maximum Profit in Job Scheduling We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\nYou\u0026rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.\n解題思路 # 每個工作都有兩種選擇，做或者不做。\n做：total profit += job porfit 不做：nothing changed 如何選擇做不做呢？可以將工作以結束時間排序，記錄下每個結束時間的最大獲利，每次決定是否要執行當前工作時，只要找到結束時間小於等於當前開始時間的最大獲利，和上個結束時間最大獲利比較，就可以決定要不要做了。\ndp[i] = max(dp[j]+profit, dp[i-1]) // j 是結束時間小於等於當前開始時間的位置 因為最大獲利根據結束時間是遞增的，可以用二元搜索找到。\n解法：DP+Binary Search # c\u0026#43;\u0026#43; class Solution { public: int jobScheduling(vector\u0026lt;int\u0026gt;\u0026amp; startTime, vector\u0026lt;int\u0026gt;\u0026amp; endTime, vector\u0026lt;int\u0026gt;\u0026amp; profit) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; jobs; for(int i = 0; i \u0026lt; startTime.size(); i++) jobs.push_back({endTime[i], startTime[i], profit[i]}); sort(jobs.begin(), jobs.end()); // 根據結束時間排序 map\u0026lt;int, int\u0026gt; dp = {{0, 0}}; for(auto job: jobs) { // 找到小於等於開始時間的最晚結束時間，並計算獲利 int cur = prev(dp.upper_bound(job[1]))-\u0026gt;second + job[2]; // 比較如果做了這個工作和不做的獲利 if (cur \u0026gt; dp.rbegin()-\u0026gt;second) dp[job[0]] = cur; } return dp.rbegin()-\u0026gt;second; } }; python class Solution: def jobScheduling(self, startTime, endTime, profit): jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1]) dp = [[0, 0]] for s, e, p in jobs: i = bisect.bisect(dp, [s+1])-1 if dp[i][1] + p \u0026gt; dp[-1][1]: dp.append([e, dp[i][1] + p]) return dp[-1][1] "},{"id":1,"href":"/algodoc/docs/leetcode/hard/2407/","title":"2407. Longest Increasing Subsequence II","section":"Hard","content":"2407. Longest Increasing Subsequence II LIS (longest increasing subsequence) 是一個經典的 dp 問題，題目簡述是，給定一個陣列並允許刪除其中某些元素，能夠構成最長的嚴格遞增陣列的長度是多少？本題是基於 LIS 的變化，新增了序列中兩個元素的差 k。\nYou are given an integer array nums and an integer k.\nFind the longest subsequence of nums that meets the following requirements:\nThe subsequence is strictly increasing and The difference between adjacent elements in the subsequence is at most k. Return the length of the longest subsequence that meets the requirements.\n解法一：DP # 建立一個 dp array，dp[i]代表的是以nums[i]做為結尾的 seq 的最大長度，做法是搜尋 dp[0] ~ dp[i-1]，找到最大的 sub-LIS，將其+1 更新dp[i]。但為了滿足相鄰的元素相減必須比k小，需要加入nums[i]-nums[j] \u0026lt;=k判斷。\nint dp[numsSize]; int max = 1; for(int i = 0; i \u0026lt; numsSize; i++) { dp[i] = 1; for(int j = 0; j \u0026lt; i; j++) dp[i] = (nums[i]\u0026gt;nums[j] \u0026amp;\u0026amp; nums[i]-nums[j] \u0026lt;=k \u0026amp;\u0026amp; dp[i] \u0026lt;= dp[j]) ? dp[j]+1: dp[i]; max = dp[i] \u0026gt; max ? dp[i] : max; } return max; TC: $O(n^2)$\n這個解法會因為超時而 TLE ，因為查詢的複雜度過高，要簡化可以使用線段樹優化區間查詢。\n解法二：DP+Segment Tree # 解法一的效能瓶頸是每次的查詢都是$n^2$，為了降低區間查詢的複雜度，可以使用線段樹來降低查詢複雜度，但為了維護樹的結構，單點修改的複雜度也提升了。\n線段樹 (Segment Tree) # 線段樹是一種高等資料結構，大部分語言的標準函式庫沒有提供類似實作或介面。線段樹的每個節點代表的是聯集左右子樹區間查詢的結果，以此題來說更新 dp[i] 時，只要查詢代表著dp[i-k]~dp[i-1] 的節點就可以了，不必造訪每個葉節點取值。\n線段樹主要有三個操作\n區間查詢 單點修改 區間修改 但本題只需要用到前兩個，並且因為所有數字結尾的 LIS 長度預設都是 0 ，不用初始化線段樹所以只要實現前兩個功能就好了。\n儲存 # 線段樹的儲存可以用陣列或串列，因為是二元樹的關係用陣列一樣可以利用 index 推算出左右子節點的位置。每個節點代表的區間在實作上我習慣用封閉區間 [start, end] 表示，根節點的 index 從 0 或 1 開始都可以，如果用 0 的話左右節點分別是 $2n+1$ 和 $2n+2$，1 的話則是 $2n$ 和 $2n+1$，我以下程式從 0 開始。\n假設一個長度為$n$ 的陣列，\nBest Case: $n$ 為 2 的次方，其對應的線段樹是一個滿二元素(full tree)，總節點數為 $2^n-1$。 Worst Case: $n$ 不是 2 的次方，每層的節點數是前幾層加起來後 +1，總節點數是$4n-1$。 因此 $4n$ 的空間是最小足夠的，上面的推論是我抄來的，我數學很爛ㄏㄏ，另外在 codeforce 有人提出迭代取代遞迴方式的線段數，只需要 $2n$的空間就可以實現。\n區間查詢 # 當要查詢的區間 [l, r] 與當前節點表示的區間 [L, R] 完全一致時，回傳此節點的值。 否則取出當前節點的中點 M，確認 [l, r] 在M 的左邊還右邊後只搜尋該半邊，如果橫跨了 M則切分 [l, r] 區間做搜尋。M 要擺在左邊或右邊也是看個人習慣，我都偏左。 c\u0026#43;\u0026#43; int query(int i, int L, int R, int l, int r) { if(l == L \u0026amp;\u0026amp; r == R) return tree[i]; int M = (L+R)\u0026gt;\u0026gt;1; if(M \u0026gt;= r) return query(i*2+1, L, M, l, r); else if(M \u0026lt; l) return query(i*2+2, M+1, R, l, r); return max(query(i*2+1, L, M, l, M), query(i*2+2, M+1, R, M+1, r)); } go func (s SegTree) Query(l, r, L, R, i int) int { if L==l \u0026amp;\u0026amp; R==r { return s[i] } M := (L+R)\u0026gt;\u0026gt;1 if M \u0026gt;= r { return s.Query(l, r, L, M, i*2+1) } else if M \u0026lt; l { return s.Query(l, r, M+1, R, i*2+2) } return max(s.Query(l, M, L, M, i*2+1), s.Query(M+1, r, M+1, R, i*2+2)) } "},{"id":2,"href":"/algodoc/docs/leetcode/hard/2493/","title":"2493. Divide Nodes Into the Maximum Number of Groups","section":"Hard","content":"2493. Divide Nodes Into the Maximum Number of Groups You are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n.\nYou are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected. Divide the nodes of the graph into m groups (1-indexed) such that:\nEach node in the graph belongs to exactly one group. For every pair of nodes in the graph that are connected by an edge [ai, bi], if ai belongs to the group with index x, and bi belongs to the group with index y, then |y - x| = 1. Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes. Return -1 if it is impossible to group the nodes with the given conditions.\nExample 1: # Input: n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]] Output: 4 Explanation: As shown in the image we: - Add node 5 to the first group. - Add node 1 to the second group. - Add nodes 2 and 4 to the third group. - Add nodes 3 and 6 to the fourth group. We can see that every edge is satisfied. It can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied. Example 2: # Input: n = 3, edges = [[1,2],[2,3],[3,1]] Output: -1 Explanation: If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied. It can be shown that no grouping is possible. 解題思路 # 先思考怎樣的情形分群會不成立，可以從範例2看到三個相連的點會失敗，如果四個五個呢？思考一下會發現奇數個節點造成的 cycle 會使得分群失敗，回傳 -1。 建立所有的 connected conponent，這可以透過 BFS/DFS/UnionFind 實作，每個conponent 會有他可以分群的最大數量，以範例 1 來說就是 5 走到 3或6 的最短距離，也就是 4。 問題變成了所有 connected conponent 最大的距離總和是多少？可以對每個點做 BFS，過程中順便檢查是否有奇數個節點的 cycle。 解法：UnionFind+BFS # c\u0026#43;\u0026#43; class UnionFind { public: unordered_map\u0026lt;int, int\u0026gt; uf; int find(int a) { if(!uf.count(a)) uf[a] = a; if(uf[a] != a) uf[a] = find(uf[a]); return uf[a]; } void merge(int a, int b) { uf[find(b)] = find(a); } }; class Solution { public: int magnificentSets(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges) { auto uf = UnionFind(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n+1); for(auto edge: edges) { graph[edge[0]].push_back(edge[1]); graph[edge[1]].push_back(edge[0]); uf.merge(edge[0], edge[1]); } vector\u0026lt;int\u0026gt; max_groups(n+1, 0); for(int i = 1; i \u0026lt; n+1; i++) { deque\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; queue = {{i, 1}}; vector\u0026lt;int\u0026gt; visited(n+1, 0); visited[i] = 1; while(!queue.empty()) { auto pop = queue.front(); int cur = pop.first, level = pop.second; queue.pop_front(); for(auto\u0026amp; edge: graph[cur]) { if(!visited[edge]) { queue.push_back({edge, level+1}); visited[edge] = level+1; } if(level == visited[edge]) return -1; } int root = uf.find(i); max_groups[root] = max(max_groups[root], level); } } int res = 0; for(int ele: max_groups) res+=ele; return res; } }; python class Solution: def magnificentSets(self, n: int, edges: List[List[int]]) -\u0026gt; int: uf = UnionFind() graph = defaultdict(list) for e1, e2 in edges: graph[e1].append(e2) graph[e2].append(e1) uf.union(e1, e2) max_groups = [0]*(n+1) for i in range(1, n+1): q = deque([(i, 1)]) visited = [0]*(n+1) visited[i] = 1 m = 0 while q: curr, level = q.popleft() m = max(m, level) for edge in graph[curr]: if not visited[edge]: q.append([edge, level+1]) visited[edge] = level+1 if level == visited[edge]: return -1 root = uf.find(i) max_groups[root] = max(max_groups[root], m) return sum(max_groups) class UnionFind: def __init__(self): self.uf = {} def union(self, a, b): roota = self.find(a) rootb = self.find(b) self.uf[rootb] = roota def find(self, a): if a not in self.uf: self.uf[a] = a if self.uf[a] != a: self.uf[a] = self.find(self.uf[a]) return self.uf[a] "},{"id":3,"href":"/algodoc/docs/leetcode/hard/446/","title":"466. Arithmetic Slices II - Subsequence","section":"Hard","content":" 466. Arithmetic Slices II - Subsequence # 466. Arithmetic Slices II - Subsequence Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n給定一個陣列，找出子序列為等差數列的數量。\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences. For example, [1, 1, 2, 5, 7] is not an arithmetic sequence. A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10]. The test cases are generated so that the answer fits in 32-bit integer.\n解題思路 # 直觀的想法是列舉所有子序列，列舉的過程判斷是否為等差。 難的點在紀錄序列，記錄每個序列的樣子太不切實際，可以改成紀錄每個等差對應的序列數量。 利用dp[i][diff]代表以arr[i]結尾，並且公差為diff的序列數量，可以歸納出以下式子。 // j for 0 to i-1 diff = nums[i]-nums[j] dp[i][diff] += dp[j][diff] + 1 解法：DP # c\u0026#43;\u0026#43; class Solution { public: int numberOfArithmeticSlices(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;unordered_map\u0026lt;long long, int\u0026gt;\u0026gt; dp(nums.size()); int res = 0; for(int i = 1; i \u0026lt; nums.size(); i++) { for(int j = 0; j \u0026lt; i; j++) { long long diff = (long long)nums[i]-nums[j]; int cnt = dp[j].count(diff) ? dp[j][diff] : 0; dp[i][diff] += cnt + 1; res += cnt; } } return res; } }; python class Solution: def numberOfArithmeticSlices(self, nums: List[int]) -\u0026gt; int: n = len(nums) dp = [defaultdict(int) for _ in range(n)] res = 0 for i in range(1, n): for j in range(i): diff = nums[i]-nums[j] cnt = dp[j][diff] dp[i][diff] += cnt+1 res += cnt return res "},{"id":4,"href":"/algodoc/docs/algorithm/range/bit/","title":"Binary Index Tree","section":"Range","content":" Binary Index Tree (Fenwick Tree) # c\u0026#43;\u0026#43; using LL = long long; class BIT { private: vector\u0026lt;int\u0026gt; tree; int n; public: BIT(int n_){ tree = vector\u0026lt;int\u0026gt;(n_, 0); n = n_; } void update(int idx, int delta) { for(idx = idx+1; idx\u0026lt;n; idx+=idx\u0026amp;(-idx)) tree[idx]+=delta; } LL prefixSum(int idx) { LL sum = 0; for(idx = idx+1; idx\u0026gt;0; idx-=idx\u0026amp;(-idx)) sum += tree[idx]; return sum; } }; "}]
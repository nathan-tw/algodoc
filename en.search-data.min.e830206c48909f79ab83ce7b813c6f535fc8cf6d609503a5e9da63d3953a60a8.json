[{"id":0,"href":"/docs/leetcode/hard/1235/","title":"1235. Maximum Profit in Job Scheduling","section":"Hard","content":" 466. Arithmetic Slices II - Subsequence # 1235. Maximum Profit in Job Scheduling We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\nYou\u0026rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.\n解題思路 # 每個工作都有兩種選擇，做或者不做。\n做：total profit += job porfit 不做：nothing changed 如何選擇做不做呢？可以將工作以結束時間排序，記錄下每個結束時間的最大獲利，每次決定是否要執行當前工作時，只要找到結束時間小於等於當前開始時間的最大獲利，和上個結束時間最大獲利比較，就可以決定要不要做了。\ndp[i] = max(dp[j]+profit, dp[i-1]) // j 是結束時間小於等於當前開始時間的位置 因為最大獲利根據結束時間是遞增的，可以用二元搜索找到。\n解法：DP+Binary Search # c\u0026#43;\u0026#43; class Solution { public: int jobScheduling(vector\u0026lt;int\u0026gt;\u0026amp; startTime, vector\u0026lt;int\u0026gt;\u0026amp; endTime, vector\u0026lt;int\u0026gt;\u0026amp; profit) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; jobs; for(int i = 0; i \u0026lt; startTime.size(); i++) jobs.push_back({endTime[i], startTime[i], profit[i]}); sort(jobs.begin(), jobs.end()); // 根據結束時間排序 map\u0026lt;int, int\u0026gt; dp = {{0, 0}}; for(auto job: jobs) { // 找到小於等於開始時間的最晚結束時間，並計算獲利 int cur = prev(dp.upper_bound(job[1]))-\u0026gt;second + job[2]; // 比較如果做了這個工作和不做的獲利 if (cur \u0026gt; dp.rbegin()-\u0026gt;second) dp[job[0]] = cur; } return dp.rbegin()-\u0026gt;second; } }; python class Solution: def jobScheduling(self, startTime, endTime, profit): jobs = sorted(zip(startTime, endTime, profit), key=lambda v: v[1]) dp = [[0, 0]] for s, e, p in jobs: i = bisect.bisect(dp, [s+1])-1 if dp[i][1] + p \u0026gt; dp[-1][1]: dp.append([e, dp[i][1] + p]) return dp[-1][1] "},{"id":1,"href":"/docs/leetcode/hard/446/","title":"466. Arithmetic Slices II - Subsequence","section":"Hard","content":" 466. Arithmetic Slices II - Subsequence # 466. Arithmetic Slices II - Subsequence Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n給定一個陣列，找出子序列為等差數列的數量。\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences. For example, [1, 1, 2, 5, 7] is not an arithmetic sequence. A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10]. The test cases are generated so that the answer fits in 32-bit integer.\n解題思路 # 直觀的想法是列舉所有子序列，列舉的過程判斷是否為等差。 難的點在紀錄序列，記錄每個序列的樣子太不切實際，可以改成紀錄每個等差對應的序列數量。 利用dp[i][diff]代表以arr[i]結尾，並且公差為diff的序列數量，可以歸納出以下式子。 // j for 0 to i-1 diff = nums[i]-nums[j] dp[i][diff] += dp[j][diff] + 1 解法：DP # c\u0026#43;\u0026#43; class Solution { public: int numberOfArithmeticSlices(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;unordered_map\u0026lt;long long, int\u0026gt;\u0026gt; dp(nums.size()); int res = 0; for(int i = 1; i \u0026lt; nums.size(); i++) { for(int j = 0; j \u0026lt; i; j++) { long long diff = (long long)nums[i]-nums[j]; int cnt = dp[j].count(diff) ? dp[j][diff] : 0; dp[i][diff] += cnt + 1; res += cnt; } } return res; } }; python class Solution: def numberOfArithmeticSlices(self, nums: List[int]) -\u0026gt; int: n = len(nums) dp = [defaultdict(int) for _ in range(n)] res = 0 for i in range(1, n): for j in range(i): diff = nums[i]-nums[j] cnt = dp[j][diff] dp[i][diff] += cnt+1 res += cnt return res "}]
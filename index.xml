<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nathan&#39;s Algodoc on algodoc</title>
    <link>https://algodoc.star-67.com/</link>
    <description>Recent content in Nathan&#39;s Algodoc on algodoc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://algodoc.star-67.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1235. Maximum Profit in Job Scheduling</title>
      <link>https://algodoc.star-67.com/docs/leetcode/hard/1235/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/leetcode/hard/1235/</guid>
      <description>1235. Maximum Profit in Job Scheduling # 1235. Maximum Profit in Job Scheduling We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].
You&amp;rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.
If you choose a job that ends at time X you will be able to start another job that starts at time X.</description>
    </item>
    
    <item>
      <title>2407. Longest Increasing Subsequence II</title>
      <link>https://algodoc.star-67.com/docs/leetcode/hard/2407/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/leetcode/hard/2407/</guid>
      <description>2407. Longest Increasing Subsequence II # 2407. Longest Increasing Subsequence II LIS (longest increasing subsequence) 是一個經典的 dp 問題，題目簡述是，給定一個陣列並允許刪除其中某些元素，能夠構成最長的嚴格遞增陣列的長度是多少？本題是基於 LIS 的變化，新增了序列中兩個元素的差 k。
You are given an integer array nums and an integer k.
Find the longest subsequence of nums that meets the following requirements:
The subsequence is strictly increasing and The difference between adjacent elements in the subsequence is at most k. Return the length of the longest subsequence that meets the requirements.</description>
    </item>
    
    <item>
      <title>2493. Divide Nodes Into the Maximum Number of Groups</title>
      <link>https://algodoc.star-67.com/docs/leetcode/hard/2493/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/leetcode/hard/2493/</guid>
      <description>2493. Divide Nodes Into the Maximum Number of Groups # 2493. Divide Nodes Into the Maximum Number of Groups You are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n.
You are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected.</description>
    </item>
    
    <item>
      <title>466. Arithmetic Slices II - Subsequence</title>
      <link>https://algodoc.star-67.com/docs/leetcode/hard/446/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/leetcode/hard/446/</guid>
      <description>466. Arithmetic Slices II - Subsequence # 466. Arithmetic Slices II - Subsequence Given an integer array nums, return the number of all the arithmetic subsequences of nums.
給定一個陣列，找出子序列為等差數列的數量。
A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.</description>
    </item>
    
    <item>
      <title>Binary Index Tree</title>
      <link>https://algodoc.star-67.com/docs/algorithm/range/bit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/algorithm/range/bit/</guid>
      <description> Binary Index Tree (Fenwick Tree) # c&amp;#43;&amp;#43; using LL = long long; class BIT { private: vector&amp;lt;int&amp;gt; tree; int n; public: BIT(int n_){ tree = vector&amp;lt;int&amp;gt;(n_, 0); n = n_; } void update(int idx, int delta) { for(idx = idx+1; idx&amp;lt;n; idx+=idx&amp;amp;(-idx)) tree[idx]+=delta; } LL prefixSum(int idx) { LL sum = 0; for(idx = idx+1; idx&amp;gt;0; idx-=idx&amp;amp;(-idx)) sum += tree[idx]; return sum; } }; </description>
    </item>
    
    <item>
      <title>Kadane&#39;s Algorithm</title>
      <link>https://algodoc.star-67.com/docs/algorithm/dp/kadane/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/algorithm/dp/kadane/</guid>
      <description> Kadane&amp;rsquo;s Algorithm # c&amp;#43;&amp;#43; int maxSubArraySum(int a[], int size) { int max_so_far = INT_MIN, max_ending_here = 0; for (int i = 0; i &amp;lt; size; i++) { max_ending_here = max_ending_here + a[i]; if (max_so_far &amp;lt; max_ending_here) max_so_far = max_ending_here; if (max_ending_here &amp;lt; 0) max_ending_here = 0; } return max_so_far; } </description>
    </item>
    
    <item>
      <title>Rolling Hash</title>
      <link>https://algodoc.star-67.com/docs/algorithm/string/rolling_hash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/algorithm/string/rolling_hash/</guid>
      <description>Rolling Hash # Rolling Hash 是一個字段比對方式，利用移動視窗計算視窗內的 hash 值，將推移視窗的複雜度從 O(n) 降到 O(1)。 做法是將字母視作一個多項式的係數，例如 a~z 對應 1~26，而這個多項式就是 hash function，以 banana 這個字串來說，要找到 ana 這個子字串該怎麼做？
計算 ana 的 hash 值 h，此時我們需要假設一個質數 x，這裡假設 x=31 ， 計算出 ana 的 h 為1551。 \[H(x) = x^2&amp;#43;19x&amp;#43;1\] 移動長度3的視窗，並同時確認 hash 值是否與 h 相同。每次移動視窗需要執行三個步驟：
將多項式同乘 base。 將多項式最後一項 (a0) 加上去。 將最高次剪去。 根據上述步驟，從 ban 轉移到 ana 的過程是：
ban 的 hash值為1972，將多項式乘以 x 得到 61132。 加上 &#39;a&#39;-&#39;a&#39;+1，得到61133。 將 x^3(59582) 減去，得到1551。 另外 hash 很容易因為過大而溢位，實作上通常會對一個夠大的質數取餘，例如我常用的 1e9+7，以下程式碼為了方便說明就沒有取餘數。</description>
    </item>
    
    <item>
      <title>UnionFind</title>
      <link>https://algodoc.star-67.com/docs/algorithm/graph/union_find/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/algorithm/graph/union_find/</guid>
      <description>UnionFind (Disjoint Set) # Set 在資訊科學中用以代表一個群體，Disjoint Set 也就是互相沒有交集的群體，做法是將群體中的一個元素作為代表，可以透過查找群體中其他成員取得這個元素，通常用來找出圖中的 connected component，也因為有兩個操作分別是 Union, Find 所以稱為 UnionFind。
Union: 將兩個群體合在一起，很直觀的將 b 原本群體的代表替換成 a 的群體。
void merge(int a, int b) { uf[find(b)] = find(a); } Find: 如果 a 找不到，代表不屬於任何一個群體，需要新建立一個。如果 a 不是群體代表，則需要向源頭尋找，並且同時做調整。
int find(int a) { if(!uf.count(a)) uf[a] = a; if(uf[a] != a) uf[a] = find(uf[a]); return uf[a]; } 將代碼整合後如下：
c&amp;#43;&amp;#43; class UnionFind { public: unordered_map&amp;lt;int, int&amp;gt; uf; int find(int a) { if(!uf.count(a)) uf[a] = a; if(uf[a] !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://algodoc.star-67.com/docs/algorithm/range/segtree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/algorithm/range/segtree/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>

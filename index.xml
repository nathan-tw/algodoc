<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nathan&#39;s Algodoc on algodoc</title>
    <link>https://algodoc.star-67.com/</link>
    <description>Recent content in Nathan&#39;s Algodoc on algodoc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://algodoc.star-67.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1235. Maximum Profit in Job Scheduling</title>
      <link>https://algodoc.star-67.com/docs/leetcode/hard/1235/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/leetcode/hard/1235/</guid>
      <description>466. Arithmetic Slices II - Subsequence # 1235. Maximum Profit in Job Scheduling We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].
You&amp;rsquo;re given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.
If you choose a job that ends at time X you will be able to start another job that starts at time X.</description>
    </item>
    
    <item>
      <title>2407. Longest Increasing Subsequence II</title>
      <link>https://algodoc.star-67.com/docs/leetcode/hard/2407/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/leetcode/hard/2407/</guid>
      <description>2407. Longest Increasing Subsequence II LIS (longest increasing subsequence) 是一個經典的 dp 問題，題目簡述是，給定一個陣列並允許刪除其中某些元素，能夠構成最長的嚴格遞增陣列的長度是多少？本題是基於 LIS 的變化，新增了序列中兩個元素的差 k。
You are given an integer array nums and an integer k.
Find the longest subsequence of nums that meets the following requirements:
The subsequence is strictly increasing and The difference between adjacent elements in the subsequence is at most k. Return the length of the longest subsequence that meets the requirements.
解法一：DP # 建立一個 dp array，dp[i]代表的是以nums[i]做為結尾的 seq 的最大長度，做法是搜尋 dp[0] ~ dp[i-1]，找到最大的 sub-LIS，將其+1 更新dp[i]。但為了滿足相鄰的元素相減必須比k小，需要加入nums[i]-nums[j] &amp;lt;=k判斷。</description>
    </item>
    
    <item>
      <title>2493. Divide Nodes Into the Maximum Number of Groups</title>
      <link>https://algodoc.star-67.com/docs/leetcode/hard/2493/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/leetcode/hard/2493/</guid>
      <description>2493. Divide Nodes Into the Maximum Number of Groups You are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n.
You are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected. Divide the nodes of the graph into m groups (1-indexed) such that:</description>
    </item>
    
    <item>
      <title>466. Arithmetic Slices II - Subsequence</title>
      <link>https://algodoc.star-67.com/docs/leetcode/hard/446/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/leetcode/hard/446/</guid>
      <description>466. Arithmetic Slices II - Subsequence # 466. Arithmetic Slices II - Subsequence Given an integer array nums, return the number of all the arithmetic subsequences of nums.
給定一個陣列，找出子序列為等差數列的數量。
A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.</description>
    </item>
    
    <item>
      <title>Binary Index Tree</title>
      <link>https://algodoc.star-67.com/docs/algorithm/range/bit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/algorithm/range/bit/</guid>
      <description> Binary Index Tree (Fenwick Tree) # c&amp;#43;&amp;#43; using LL = long long; class BIT { private: vector&amp;lt;int&amp;gt; tree; int n; public: BIT(int n_){ tree = vector&amp;lt;int&amp;gt;(n_, 0); n = n_; } void update(int idx, int delta) { for(idx = idx+1; idx&amp;lt;n; idx+=idx&amp;amp;(-idx)) tree[idx]+=delta; } LL prefixSum(int idx) { LL sum = 0; for(idx = idx+1; idx&amp;gt;0; idx-=idx&amp;amp;(-idx)) sum += tree[idx]; return sum; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://algodoc.star-67.com/docs/algorithm/range/segtree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://algodoc.star-67.com/docs/algorithm/range/segtree/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
